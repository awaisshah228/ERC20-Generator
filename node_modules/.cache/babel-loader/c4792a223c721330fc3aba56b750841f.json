{"ast":null,"code":"var assert = require('assert');\n\nvar translate = require('./translate.js');\n\nvar linker = require('./linker.js');\n\nvar requireFromString = require('require-from-string');\n\nvar https = require('https');\n\nvar MemoryStream = require('memorystream');\n\nfunction setupMethods(soljson) {\n  var compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number']);\n  var compileJSONMulti = null;\n\n  if ('_compileJSONMulti' in soljson) {\n    compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number']);\n  }\n\n  var compileJSONCallback = null;\n  var compileStandard = null;\n\n  if ('_compileJSONCallback' in soljson || '_compileStandard' in soljson) {\n    var copyString = function copyString(str, ptr) {\n      var length = soljson.lengthBytesUTF8(str);\n\n      var buffer = soljson._malloc(length + 1);\n\n      soljson.stringToUTF8(str, buffer, length + 1);\n      soljson.setValue(ptr, buffer, '*');\n    };\n\n    var wrapCallback = function wrapCallback(callback) {\n      assert(typeof callback === 'function', 'Invalid callback specified.');\n      return function (path, contents, error) {\n        var result = callback(soljson.Pointer_stringify(path));\n\n        if (typeof result.contents === 'string') {\n          copyString(result.contents, contents);\n        }\n\n        if (typeof result.error === 'string') {\n          copyString(result.error, error);\n        }\n      };\n    }; // This calls compile() with args || cb\n\n\n    var runWithReadCallback = function runWithReadCallback(readCallback, compile, args) {\n      if (readCallback === undefined) {\n        readCallback = function readCallback(path) {\n          return {\n            error: 'File import callback not supported'\n          };\n        };\n      }\n\n      var cb = soljson.Runtime.addFunction(wrapCallback(readCallback));\n      var output;\n\n      try {\n        args.push(cb);\n        output = compile.apply(undefined, args);\n      } catch (e) {\n        soljson.Runtime.removeFunction(cb);\n        throw e;\n      }\n\n      soljson.Runtime.removeFunction(cb);\n      return output;\n    };\n\n    var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number']);\n\n    compileJSONCallback = function compileJSONCallback(input, optimize, readCallback) {\n      return runWithReadCallback(readCallback, compileInternal, [input, optimize]);\n    };\n\n    if ('_compileStandard' in soljson) {\n      var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number']);\n\n      compileStandard = function compileStandard(input, readCallback) {\n        return runWithReadCallback(readCallback, compileStandardInternal, [input]);\n      };\n    }\n  }\n\n  var compile = function compile(input, optimise, readCallback) {\n    var result = '';\n\n    if (readCallback !== undefined && compileJSONCallback !== null) {\n      result = compileJSONCallback(JSON.stringify(input), optimise, readCallback);\n    } else if (typeof input !== 'string' && compileJSONMulti !== null) {\n      result = compileJSONMulti(JSON.stringify(input), optimise);\n    } else {\n      result = compileJSON(input, optimise);\n    }\n\n    return JSON.parse(result);\n  }; // Expects a Standard JSON I/O but supports old compilers\n\n\n  var compileStandardWrapper = function compileStandardWrapper(input, readCallback) {\n    if (compileStandard !== null) {\n      return compileStandard(input, readCallback);\n    }\n\n    function formatFatalError(message) {\n      return JSON.stringify({\n        errors: [{\n          'type': 'SOLCError',\n          'component': 'solcjs',\n          'severity': 'error',\n          'message': message,\n          'formattedMessage': 'Error: ' + message\n        }]\n      });\n    }\n\n    if (readCallback !== undefined && typeof readCallback !== 'function') {\n      return formatFatalError('Invalid import callback supplied');\n    }\n\n    input = JSON.parse(input);\n\n    if (input['language'] !== 'Solidity') {\n      return formatFatalError('Only Solidity sources are supported');\n    }\n\n    if (input['sources'] == null) {\n      return formatFatalError('No input specified');\n    } // Bail out early\n\n\n    if (input['sources'].length > 1 && compileJSONMulti === null) {\n      return formatFatalError('Multiple sources provided, but compiler only supports single input');\n    }\n\n    function isOptimizerEnabled(input) {\n      return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled'];\n    }\n\n    function translateSources(input) {\n      var sources = {};\n\n      for (var source in input['sources']) {\n        if (input['sources'][source]['content'] !== null) {\n          sources[source] = input['sources'][source]['content'];\n        } else {\n          // force failure\n          return null;\n        }\n      }\n\n      return sources;\n    }\n\n    function librariesSupplied(input) {\n      if (input['settings'] !== null) {\n        return input['settings']['libraries'];\n      }\n    }\n\n    function translateOutput(output) {\n      output = translate.translateJsonCompilerOutput(JSON.parse(output));\n\n      if (output == null) {\n        return formatFatalError('Failed to process output');\n      }\n\n      return JSON.stringify(output);\n    }\n\n    var sources = translateSources(input);\n\n    if (sources === null || Object.keys(sources).length === 0) {\n      return formatFatalError('Failed to process sources');\n    } // Try linking if libraries were supplied\n\n\n    var libraries = librariesSupplied(input); // Try to wrap around old versions\n\n    if (compileJSONCallback !== null) {\n      return translateOutput(compileJSONCallback(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input), readCallback), libraries);\n    }\n\n    if (compileJSONMulti !== null) {\n      return translateOutput(compileJSONMulti(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input)), libraries);\n    } // Try our luck with an ancient compiler\n\n\n    return translateOutput(compileJSON(sources[Object.keys(sources)[0]], isOptimizerEnabled(input)), libraries);\n  };\n\n  var version = soljson.cwrap('version', 'string', []);\n\n  var versionToSemver = function versionToSemver() {\n    return translate.versionToSemver(version());\n  };\n\n  var license = function license() {// return undefined\n  };\n\n  if ('_license' in soljson) {\n    license = soljson.cwrap('license', 'string', []);\n  }\n\n  return {\n    version: version,\n    semver: versionToSemver,\n    license: license,\n    compile: compile,\n    compileStandard: compileStandard,\n    compileStandardWrapper: compileStandardWrapper,\n    linkBytecode: linker.linkBytecode,\n    supportsMulti: compileJSONMulti !== null,\n    supportsImportCallback: compileJSONCallback !== null,\n    supportsStandard: compileStandard !== null,\n    // Loads the compiler of the given version from the github repository\n    // instead of from the local filesystem.\n    loadRemoteVersion: function loadRemoteVersion(versionString, cb) {\n      var mem = new MemoryStream(null, {\n        readable: false\n      });\n      var url = 'https://ethereum.github.io/solc-bin/bin/soljson-' + versionString + '.js';\n      https.get(url, function (response) {\n        if (response.statusCode !== 200) {\n          cb(new Error('Error retrieving binary: ' + response.statusMessage));\n        } else {\n          response.pipe(mem);\n          response.on('end', function () {\n            cb(null, setupMethods(requireFromString(mem.toString(), 'soljson-' + versionString + '.js')));\n          });\n        }\n      }).on('error', function (error) {\n        cb(error);\n      });\n    },\n    // Use this if you want to add wrapper functions around the pure module.\n    setupMethods: setupMethods\n  };\n}\n\nmodule.exports = setupMethods;","map":null,"metadata":{},"sourceType":"script"}